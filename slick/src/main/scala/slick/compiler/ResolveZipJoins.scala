package slick.compiler

import scala.collection.mutable.{HashMap, ArrayBuffer}
import slick.{SlickTreeException, SlickException}
import slick.ast._
import Util._
import ExtraUtil._
import TypeUtil._

/** Rewrite zip joins into a form suitable for SQL (using inner joins and
  * RowNumber columns.
  * We rely on having a Bind around every Join and both of its generators,
  * which should have been generated by Phase.forceOuterBinds. The inner
  * Binds need to select Pure(StructNode(...)) which should be the outcome
  * of Phase.flattenProjections. */
class ResolveZipJoins extends Phase {
  type State = ResolveZipJoinsState
  val name = "resolveZipJoins"

  def apply(state: CompilerState) = {
    val n2 = resolveZipJoins(state.tree)
    state + (this -> new State(n2 ne state.tree)) withNode n2
  }

  def resolveZipJoins(n: Node): Node = (n match {
    // zip with index
    case Bind(oldBindSym, Join(_, _,
        l @ Bind(lsym, lfrom, Pure(StructNode(lstruct), _)),
        RangeFrom(offset),
        JoinType.Zip, LiteralNode(true)), Pure(sel, _)) =>
      val idxSym = new AnonSymbol
      val idxExpr =
        if(offset == 1L) RowNumber()
        else Library.-.typed[Long](RowNumber(), LiteralNode(1L - offset))
      val innerBind = Bind(lsym, lfrom, Pure(StructNode(lstruct :+ (idxSym, idxExpr)))).nodeWithComputedType()
      val bindSym = new AnonSymbol
      val OldBindRef = Ref(oldBindSym)
      val bindRef = Ref(bindSym) :@ innerBind.nodeType.asCollectionType.elementType
      val newOuterSel = sel.replace {
        case Select(OldBindRef, ElementSymbol(1)) => bindRef
        case Select(OldBindRef, ElementSymbol(2)) => Select(bindRef, idxSym).nodeWithComputedType()
      }
      Bind(bindSym, innerBind, Pure(newOuterSel)).nodeWithComputedType(SymbolScope.empty, false, true)

    // zip with another query
    case b @ Bind(_, Join(jlsym, jrsym,
        l @ Bind(lsym, lfrom, Pure(StructNode(lstruct), ts1)),
        r @ Bind(rsym, rfrom, Pure(StructNode(rstruct), ts2)),
        JoinType.Zip, LiteralNode(true)), _) =>
      val lIdxSym, rIdxSym = new AnonSymbol
      val lInnerBind = Bind(lsym, lfrom, Pure(StructNode(lstruct :+ (lIdxSym, RowNumber())), ts1)).nodeWithComputedType(retype = true)
      val rInnerBind = Bind(rsym, rfrom, Pure(StructNode(rstruct :+ (rIdxSym, RowNumber())), ts2)).nodeWithComputedType(retype = true)
      val jlRef = Ref(jlsym) :@ lInnerBind.nodeType.asCollectionType.elementType
      val jrRef = Ref(jrsym) :@ rInnerBind.nodeType.asCollectionType.elementType
      val join = Join(jlsym, jrsym, lInnerBind, rInnerBind, JoinType.Inner,
        Library.==.typed[Boolean](Select(jlRef, lIdxSym).nodeWithComputedType(), Select(jrRef, rIdxSym).nodeWithComputedType())
      )
      b.copy(from = join)

    case n => n
  }).nodeMapChildren(resolveZipJoins, keepType = true)
}

class ResolveZipJoinsState(val hasRowNumber: Boolean)

/** Inject the proper orderings into the RowNumber nodes produced earlier by
  * the resolveFixJoins phase. */
class FixRowNumberOrdering extends Phase {
  val name = "fixRowNumberOrdering"

  def apply(state: CompilerState) = state.map { n =>
    if(state.get(Phase.resolveZipJoins).map(_.hasRowNumber).getOrElse(true))
      fixRowNumberOrdering(n)
    else {
      logger.debug("No row numbers to fix")
      n
    }
  }

  /** Push ORDER BY into RowNumbers in ordered Comprehensions. */
  def fixRowNumberOrdering(n: Node, parent: Option[Comprehension] = None): Node = (n, parent) match {
    case (r @ RowNumber(_), Some(c)) if !c.orderBy.isEmpty =>
      RowNumber(c.orderBy).nodeTyped(r.nodeType)
    case (c: Comprehension, _) => c.nodeMapScopedChildren {
      case (Some(gen), ch) => fixRowNumberOrdering(ch, None)
      case (None, ch) => fixRowNumberOrdering(ch, Some(c))
    }.nodeWithComputedType()
    case (n, _) => n.nodeMapChildren(ch => fixRowNumberOrdering(ch, parent), keepType = true)
  }
}
